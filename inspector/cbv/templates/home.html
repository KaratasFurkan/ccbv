{% extends 'base.html' %}


{% block page_header %}<h1>Classy &mdash; understand Django's class-based views.</h1>{% endblock %}


{% block breadcrumb_wrap %}{% endblock %}

{% block content %}
    <div class="span6">
        <h2>What's a class-based view anyway?</h2>

        <p><a href="http://djangoproject.com/">Django</a> 1.3 came with class-based generic views. These are really awesome, and
        very powerfully coded, with mixins and base classes all over the shop. This
        means they're much more than just a couple of generic shortcuts: they also
        provide utilities which can be mixed into the much more complex views that you
        write yourself.</p>

        <h2>Great! So what's the point of the inspector?</h2>

        <p>All of this power comes at the expense of simplicity. Trying to work out
        exactly which method you need to customise on your <code>UpdateView</code> can feel a
        little like wading through spaghetti: it has 8 separate ancestors (plus
        <code>object</code>) spread across 3 different files. So working out that you wanted to
        tweak <code>UpdateView.get_initial</code> (and what its keyword arguments are) is a bit of
        a faff.</p>
    </div>
    <div class="span6">
        <div class="hero-unit">
            <h1>Take a look!</h1>
            <p>We think that the best way to document Django's class-based views is to show you the code, so pick your version and jump in at the deep end:</p>
            {% for pv in projectversion_list %}
                <a class="btn btn-large{% if forloop.first %} btn-primary{% endif %}" href="{{ pv.get_absolute_url }}">{{ pv }}</a>
            {% endfor %}
        </div>
    </div>
{% endblock %}
