{% extends 'base.html' %}


{% block page_header %}<h1>Classy &mdash; understand Django's class-based views.</h1>{% endblock %}


{% block breadcrumb_wrap %}{% endblock %}

{% block content %}
    <div class="span8">
        <h2>What's a class-based view anyway?</h2>

        <p>Django 1.3 came with class-based generic views. These are really awesome, and
        very powerfully coded with mixins and base classes all over the shop. This
        means they're much more than just a couple of generic shortcuts, they also
        provide utilities which can be mixed into the much more complex views that you
        write yourself.</p>

        <h2>Great! So what's the point of the inspector?</h2>

        <p>All of this power comes at the expense of simplicity. Trying to work out
        exactly which method you need to customise on your <code>UpdateView</code> can feel a
        little like wading through spaghetti: it has 8 separate ancestors (plus
        <code>object</code>) spread across 3 different files. So working out that you wanted to
        tweak <code>UpdateView.get_initial</code> and what its keyword arguments are is a bit of
        a faff.</p>
    </div>
    <div class="span4">
        <h2>Versions</h2>
        {% for pv in projectversion_list %}
            {% if forloop.first %}<ul>{% endif %}
            <li><a href="{{ pv.get_absolute_url }}">{{ pv }}</a></li>
            {% if forloop.last %}</ul>{% endif %}
        {% endfor %}
    </div>
{% endblock %}
